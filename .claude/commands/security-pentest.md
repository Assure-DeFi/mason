---
name: security-pentest
version: 1.0.0
description: Shannon-inspired autonomous security penetration testing for web apps
---

# Security Pentest - Autonomous White-Box Security Testing

You are the **Security Pentest Coordinator**. This skill autonomously discovers, exploits, fixes, and verifies security vulnerabilities in any web app running on localhost. Methodology adapted from Shannon (KeygraphHQ) penetration testing principles.

**Core principle: "No Exploit, No Report"** - only confirmed, reproducible vulnerabilities get reported.

## Arguments

Parse arguments from `$ARGUMENTS`:

- `--fix-mode report-only` - Detection only, no fixes applied
- `--focus <area>` - Focus on: `injection`, `xss`, `auth`, `authz`, `headers`, or `all` (default)
- `--phase <n>` - Run only up to phase N (1-6)
- `--severity <level>` - Minimum severity to report: `critical`, `high`, `medium` (default), `low`, `info`

## Step 1: Initialize State (MANDATORY)

Create the directory structure:

```bash
mkdir -p .claude/security-pentest/recon
mkdir -p .claude/security-pentest/analysis
mkdir -p .claude/security-pentest/exploitation
mkdir -p .claude/security-pentest/fixes
```

Then use the Write tool to create `.claude/security-pentest/index.json`:

```json
{
  "run_id": "sp-YYYYMMDD-HHMMSS",
  "status": "initializing",
  "phase": 0,
  "started_at": "<current ISO timestamp>",
  "config": {
    "fix_mode": "auto-fix",
    "focus": "all",
    "max_phase": 6,
    "min_severity": "medium"
  },
  "base_url": "http://localhost:3000",
  "recon": { "status": "pending" },
  "analysis": { "status": "pending", "categories": {} },
  "exploitation": { "status": "pending", "confirmed": [] },
  "fixes": { "status": "pending", "applied": [] },
  "verification": { "status": "pending", "results": [] }
}
```

## Step 2: Check Dev Server (MANDATORY)

```bash
curl -s -o /dev/null -w "%{http_code}" http://localhost:3000 2>/dev/null || echo "NOT_RUNNING"
```

If NOT_RUNNING: Tell user to start dev server and wait. If 200: Proceed.

## Step 3: Phase 1 - Reconnaissance (Wave 1 - 2 Explore Agents, Parallel)

Update `index.json`: set `"status": "recon"`, `"phase": 1`

**IMPORTANT: Launch BOTH agents in a SINGLE message with 2 Task tool calls.**

### Agent A: Source Code Analyzer (Explore)

Use Task tool with `subagent_type: "Explore"` and this prompt:

```
You are the Source Code Analyzer for a security penetration test.

YOUR TASK: Perform deep source code analysis to identify security-relevant patterns.

STEP 1: Auto-detect the framework
- Look for next.config.js/ts, package.json, app/ vs pages/ directory
- Identify: Next.js version, database (Supabase/Prisma/etc), auth library

STEP 2: Find ALL authentication patterns
- Search for: getServerSession, getSession, useSession, NextAuth, JWT verification
- Search for: middleware.ts, auth checks in API routes
- Map: which routes have auth, which don't

STEP 3: Find ALL database query patterns
- Search for: .from(), .select(), .insert(), .update(), .delete() (Supabase)
- Search for: raw SQL, template literals near queries, string interpolation in queries
- Search for: ORM calls (Prisma, Drizzle, etc.)
- For EACH query: note if user input flows into it and how

STEP 4: Find ALL input sources
- Search for: req.body, req.query, req.params, searchParams, formData
- Search for: URL parameters used in queries or rendering
- Search for: headers used in logic (X-Forwarded-For, Referer, etc.)

STEP 5: Find ALL dangerous sinks
- Search for: exec(), execSync(), spawn(), child_process usage
- Search for: fs.readFile/writeFile with dynamic paths
- Search for: dangerouslySetInnerHTML, eval(), Function()
- Search for: redirect() with user-controlled URLs

STEP 6: Map data flows
For each input source found, trace where it goes:
- Input -> processing -> database query (SQL injection risk)
- Input -> processing -> HTML render (XSS risk)
- Input -> processing -> shell command (command injection risk)
- Input -> processing -> file path (path traversal risk)

OUTPUT: Use the Write tool to create .claude/security-pentest/recon/source-analysis.json:

{
  "framework": { "name": "...", "version": "...", "database": "...", "auth": "..." },
  "auth_patterns": [
    {
      "file": "src/...",
      "type": "getServerSession|middleware|api_key_check|none",
      "protected": true/false,
      "notes": "..."
    }
  ],
  "database_queries": [
    {
      "file": "src/...",
      "line": 45,
      "type": "supabase|raw_sql|orm",
      "parameterized": true/false,
      "user_input_flows_in": true/false,
      "input_source": "req.body.name or null",
      "risk": "none|low|medium|high"
    }
  ],
  "input_sources": [
    {
      "file": "src/...",
      "line": 12,
      "type": "body|query|params|searchParams|header",
      "field": "field_name",
      "sanitized": true/false,
      "flows_to": ["database", "render", "shell", "file_path"]
    }
  ],
  "dangerous_sinks": [
    {
      "file": "src/...",
      "line": 30,
      "type": "exec|dangerouslySetInnerHTML|eval|redirect|fs",
      "user_controlled_input": true/false,
      "risk": "critical|high|medium|low"
    }
  ],
  "data_flows": [
    {
      "source": "req.body.name in src/app/api/example/route.ts:12",
      "processing": "none|sanitized|validated",
      "sink": "supabase .eq() in src/app/api/example/route.ts:25",
      "risk_category": "injection|xss|command_injection|path_traversal",
      "risk_level": "critical|high|medium|low|none"
    }
  ]
}
```

### Agent B: Attack Surface Mapper (Explore)

Use Task tool with `subagent_type: "Explore"` and this prompt:

```
You are the Attack Surface Mapper for a security penetration test.

YOUR TASK: Map the complete attack surface of the application.

STEP 1: Discover ALL API routes
- Glob for: src/app/api/**/route.ts and src/app/api/**/route.js
- For each route: extract exported HTTP methods (GET, POST, PUT, DELETE, PATCH)
- Note which accept request bodies and what fields they expect

STEP 2: Discover ALL pages
- Glob for: src/app/**/page.tsx and src/app/**/page.js
- Note which use dynamic segments ([id], [slug], etc.)
- Note which use searchParams or URL params

STEP 3: For each API endpoint, determine:
- Does it check authentication? (search for getServerSession, auth checks)
- What parameters does it accept?
- What does it do with those parameters?
- Does it return sensitive data?

STEP 4: Find middleware
- Check for middleware.ts at project root and in subdirectories
- Check for next.config.js security headers
- Check for CORS configuration

STEP 5: Check for secrets exposure
- Search for .env files (not .env.example) committed to repo
- Search for hardcoded API keys, tokens, passwords in source code
- Search for: process.env references to understand what secrets exist
- Check if any secrets are exposed to client-side (NEXT_PUBLIC_ prefix)
- Check for credentials in localStorage that shouldn't be there

STEP 6: Check for sensitive file exposure
- Check if source maps are enabled in production config
- Check for exposed config files, backup files, debug endpoints
- Check next.config.js for any rewrites/redirects that expose internal paths

OUTPUT: Use the Write tool to create .claude/security-pentest/recon/attack-surface.json:

{
  "api_routes": [
    {
      "path": "/api/example",
      "file": "src/app/api/example/route.ts",
      "methods": ["GET", "POST"],
      "auth_required": true/false,
      "auth_method": "getServerSession|api_key|none",
      "parameters": [
        { "name": "field", "source": "body|query|params", "type": "string", "validated": true/false }
      ],
      "returns_sensitive_data": true/false,
      "notes": "..."
    }
  ],
  "pages": [
    {
      "path": "/admin/backlog",
      "file": "src/app/admin/backlog/page.tsx",
      "dynamic_segments": [],
      "uses_search_params": true/false,
      "client_side_auth": true/false,
      "server_side_auth": true/false
    }
  ],
  "middleware": {
    "exists": true/false,
    "file": "middleware.ts",
    "protected_paths": ["/admin/*", "/api/*"],
    "notes": "..."
  },
  "security_headers": {
    "csp": "present|missing|weak",
    "hsts": "present|missing",
    "x_frame_options": "present|missing",
    "x_content_type_options": "present|missing",
    "referrer_policy": "present|missing",
    "cors": "restrictive|permissive|wildcard|not_configured"
  },
  "secrets_exposure": [
    {
      "type": "hardcoded_key|env_leak|client_exposure|committed_env",
      "file": "src/...",
      "detail": "...",
      "severity": "critical|high|medium|low"
    }
  ],
  "attack_surface_summary": {
    "total_api_routes": 0,
    "unprotected_api_routes": 0,
    "total_pages": 0,
    "dynamic_pages": 0,
    "input_vectors": 0
  }
}
```

## Step 4: Phase 2 - Vulnerability Analysis (Wave 2 - Up to 5 Agents, Parallel)

Update `index.json`: set `"status": "analyzing"`, `"phase": 2`

Read the recon outputs first:

- `.claude/security-pentest/recon/source-analysis.json`
- `.claude/security-pentest/recon/attack-surface.json`

Based on the `--focus` argument, launch the relevant agents. If `--focus all`, launch ALL 5. Otherwise launch only the matching agent.

**IMPORTANT: Launch all applicable agents in a SINGLE message.**

Each agent below uses `subagent_type: "general-purpose"`. Provide each agent with the FULL contents of both recon JSON files in its prompt.

### INJECTION Agent

```
You are the INJECTION vulnerability analyzer for a security pentest.

RECON DATA:
<paste source-analysis.json content>
<paste attack-surface.json content>

YOUR TASK: Analyze for SQL injection, command injection, and path traversal vulnerabilities.

CHECK 1: SQL Injection
- For each database query in the recon data where user_input_flows_in=true:
  - Is the query parameterized? (.eq(), .filter() with values = safe; string interpolation = vulnerable)
  - Can user input modify query structure?
  - Rate: parameterized Supabase methods = safe, string concatenation = critical

CHECK 2: Command Injection
- For each dangerous_sink of type "exec" or "spawn":
  - Does user input reach it?
  - Is input sanitized/escaped?
  - Can shell metacharacters (;, |, &&, $()) be injected?

CHECK 3: Path Traversal
- For each dangerous_sink of type "fs":
  - Does user input control file paths?
  - Is path.join() or path.resolve() used without validation?
  - Can ../ sequences escape intended directory?

CHECK 4: Template Injection
- For each dangerous_sink of type "eval" or "Function":
  - Does user input reach it?
  - Is there server-side template rendering with user data?

For EACH finding, provide:
- Exact file and line number
- The vulnerable code pattern
- A concrete exploit payload
- Severity rating with justification
- Whether it's CONFIRMED (can construct working exploit) or SUSPECTED (needs live testing)

OUTPUT: Use Write tool to create .claude/security-pentest/analysis/injection.json:

{
  "category": "injection",
  "findings": [
    {
      "id": "INJ-001",
      "type": "sql_injection|command_injection|path_traversal|template_injection",
      "severity": "critical|high|medium|low",
      "confidence": "confirmed|suspected",
      "file": "src/app/api/.../route.ts",
      "line": 45,
      "vulnerable_code": "the exact vulnerable code snippet",
      "exploit_payload": "concrete payload to test",
      "exploit_url": "curl command or URL to test against",
      "impact": "what an attacker could do",
      "remediation": "how to fix it"
    }
  ],
  "summary": {
    "total_findings": 0,
    "critical": 0,
    "high": 0,
    "medium": 0,
    "low": 0
  }
}

If no findings: return empty findings array with zeroed summary.
```

### XSS Agent

```
You are the XSS vulnerability analyzer for a security pentest.

RECON DATA:
<paste source-analysis.json content>
<paste attack-surface.json content>

YOUR TASK: Analyze for Cross-Site Scripting vulnerabilities.

CHECK 1: Stored XSS
- Find user content that gets stored then rendered to other users
- Check if stored content is sanitized before rendering
- Look for rich text editors, markdown renderers, user profile fields

CHECK 2: Reflected XSS
- Find URL parameters or search queries rendered in page output
- Check if reflected values are HTML-escaped
- Look for searchParams used directly in JSX

CHECK 3: DOM-based XSS
- Find dangerouslySetInnerHTML usage
- Find direct DOM manipulation with user data
- Check for innerHTML assignments in useEffect or event handlers

CHECK 4: CSP Bypass
- Check if Content-Security-Policy header exists
- If it does: is it strict enough to block inline scripts?
- If not: all XSS findings are elevated in severity

For EACH finding provide: id, file, line, vulnerable code, exploit payload, severity, confidence.

OUTPUT: Use Write tool to create .claude/security-pentest/analysis/xss.json with same structure as injection.json but category "xss" and type values: "stored_xss|reflected_xss|dom_xss".
```

### AUTH Agent

```
You are the AUTH vulnerability analyzer for a security pentest.

RECON DATA:
<paste source-analysis.json content>
<paste attack-surface.json content>

YOUR TASK: Analyze for authentication bypass vulnerabilities.

CHECK 1: Missing Auth on API Routes
- For EACH API route in the attack surface:
  - Does it check authentication?
  - If not: what data does it expose or what actions does it allow?
  - Rate severity based on what's accessible without auth

CHECK 2: Session Security
- How are sessions managed? (JWT, cookie, token)
- Is session token httpOnly? secure? sameSite?
- Is there session fixation risk?
- Is there token reuse after logout?

CHECK 3: API Key Security
- How are API keys validated?
- Is there timing attack protection (constant-time comparison)?
- Is there brute force protection (rate limiting)?
- Are API keys hashed before storage?

CHECK 4: OAuth Security
- Is state parameter validated in OAuth callback?
- Is redirect_uri validated?
- Are tokens stored securely?

For EACH finding provide: id, file, line, description, exploit approach, severity, confidence.

OUTPUT: Use Write tool to create .claude/security-pentest/analysis/auth.json with same structure, category "auth", type values: "missing_auth|weak_session|api_key_weakness|oauth_flaw".
```

### AUTHZ Agent

```
You are the AUTHZ (authorization) vulnerability analyzer for a security pentest.

RECON DATA:
<paste source-analysis.json content>
<paste attack-surface.json content>

YOUR TASK: Analyze for authorization and access control vulnerabilities.

CHECK 1: IDOR (Insecure Direct Object Reference)
- For each API route that takes an ID parameter:
  - Does the query filter by the authenticated user_id?
  - Can user A access user B's resources by changing the ID?
  - Check both read and write operations

CHECK 2: Missing RLS (Row Level Security)
- Read the migration SQL for RLS policies
- Are ALL tables protected by RLS?
- Do RLS policies correctly restrict to the authenticated user?
- Are there tables with "USING (true)" that should be restricted?

CHECK 3: Privilege Escalation
- Can regular users access admin endpoints?
- Is role checking implemented and enforced?
- Can users modify their own role/permissions?

CHECK 4: Mass Assignment
- Do POST/PUT endpoints accept arbitrary fields?
- Can users set fields they shouldn't (role, user_id, admin)?
- Is there input validation on what fields are accepted?

For EACH finding provide: id, file, line, description, exploit approach, severity, confidence.

OUTPUT: Use Write tool to create .claude/security-pentest/analysis/authz.json with same structure, category "authz", type values: "idor|missing_rls|privilege_escalation|mass_assignment".
```

### HEADERS Agent

```
You are the HEADERS & secrets vulnerability analyzer for a security pentest.

RECON DATA:
<paste source-analysis.json content>
<paste attack-surface.json content>

YOUR TASK: Analyze security headers and secrets exposure.

CHECK 1: Security Headers
Read next.config.js/ts and middleware.ts for header configuration.
Required headers and their expected values:
- Content-Security-Policy: must restrict script-src, no 'unsafe-inline' without nonce
- Strict-Transport-Security: must be present with max-age >= 31536000
- X-Frame-Options: must be DENY or SAMEORIGIN
- X-Content-Type-Options: must be nosniff
- Referrer-Policy: must be strict-origin-when-cross-origin or stricter
- Permissions-Policy: should restrict camera, microphone, geolocation

CHECK 2: CORS Configuration
- Find CORS headers in API routes or middleware
- Access-Control-Allow-Origin: * is critical if authenticated endpoints
- Check if credentials are allowed with wildcard origin

CHECK 3: Secrets in Source Code
- Grep for patterns: api_key, secret, password, token, bearer, sk-, pk_
- Check for hardcoded credentials in test files or config
- Verify no .env file is committed (check .gitignore)
- Check if NEXT_PUBLIC_ env vars expose sensitive data

CHECK 4: Client-Side Secrets
- Search client components for credentials stored in localStorage
- Check if API keys or tokens are exposed in client bundles
- Verify server-only secrets aren't imported in client components

For EACH finding provide: id, file, line, description, severity, confidence.

OUTPUT: Use Write tool to create .claude/security-pentest/analysis/headers.json with same structure, category "headers", type values: "missing_header|weak_csp|cors_misconfiguration|exposed_secret|client_secret".
```

## Step 5: Phase 3 - Exploitation (Wave 3 - Parallel, One Agent Per Category With Findings)

Update `index.json`: set `"status": "exploiting"`, `"phase": 3`

Read ALL analysis files. For each category that has findings with confidence "confirmed" or "suspected" with severity >= the configured minimum:

Launch one `webapp-testing` agent per category that has findings.

**IMPORTANT: Launch all applicable agents in a SINGLE message.**

Each exploitation agent gets this prompt template (customize per category):

```
You are the EXPLOITATION agent for {CATEGORY} vulnerabilities.

BASE URL: http://localhost:3000

FINDINGS TO EXPLOIT:
<paste the findings array from analysis/{category}.json>

YOUR TASK: Attempt to exploit each finding against the live application. This is authorized white-box security testing against localhost only.

SAFETY CONSTRAINTS:
- ONLY test against localhost:3000
- Prefer read-only exploitation (SELECT injection, not DROP TABLE)
- NEVER run destructive payloads (no rm, DROP, DELETE, TRUNCATE)
- Restore any test data you modify
- Do NOT test against any external URLs

FOR EACH FINDING:

1. Craft the exploit request based on the exploit_payload from analysis
2. Execute it using Playwright's request context or page navigation
3. Record the FULL request and response
4. Determine if the exploit succeeded:
   - For injection: Did the response contain data it shouldn't?
   - For XSS: Did a script execute or was payload reflected unescaped?
   - For auth: Did you access protected data without auth?
   - For authz: Did you access another user's data?
   - For headers: Verify the header is actually missing in live response

5. If exploit SUCCEEDS: Record as "confirmed" with full evidence
6. If exploit FAILS: Record as "not_exploitable" and discard
   "No Exploit, No Report" - unconfirmed findings are DISCARDED

SEVERITY CLASSIFICATION:
- Critical: Remote code execution, full database access, auth bypass to admin
- High: Data of other users accessible, stored XSS, missing auth on write endpoints
- Medium: Missing security headers, reflected XSS requiring user interaction, IDOR on non-sensitive data
- Low: Information disclosure, verbose error messages, missing optional headers
- Info: Best practice recommendations, defense-in-depth suggestions

OUTPUT: Use Write tool to create .claude/security-pentest/exploitation/{category}-evidence.json:

{
  "category": "{category}",
  "tested_at": "<ISO timestamp>",
  "findings": [
    {
      "id": "INJ-001",
      "status": "confirmed|not_exploitable",
      "severity": "critical|high|medium|low|info",
      "exploit_request": {
        "method": "POST",
        "url": "http://localhost:3000/api/...",
        "headers": {},
        "body": "..."
      },
      "exploit_response": {
        "status_code": 200,
        "body_preview": "first 500 chars of response..."
      },
      "proof_of_concept": "curl command that reproduces the exploit",
      "impact_demonstrated": "what was actually achieved",
      "file": "src/...",
      "line": 45
    }
  ],
  "summary": {
    "total_tested": 0,
    "confirmed": 0,
    "not_exploitable": 0
  }
}

Discard (set status "not_exploitable") any finding you cannot confirm with a working exploit.
```

After all exploitation agents complete, update `index.json` exploitation section with the confirmed findings across all categories.

If ZERO findings are confirmed: Skip to Phase 6 (Report).

## Step 6: Phase 4 - Fix Implementation (Wave 4 - Sequential)

If `config.fix_mode === "report-only"`, skip to Phase 6.

Update `index.json`: set `"status": "fixing"`, `"phase": 4`

Read all exploitation evidence files. Collect all confirmed findings with severity >= configured minimum.

**For EACH confirmed finding (ONE AT A TIME, sequentially):**

Launch 1 `general-purpose` agent:

```
You are the Security Fix Agent.

YOUR TASK: Fix vulnerability {FINDING_ID}

VULNERABILITY DETAILS:
<paste the confirmed finding from exploitation evidence>

STEP 1: Read the vulnerable file at the specified path and line

STEP 2: Apply the MINIMAL security fix. Fix patterns by category:

- SQL Injection: Use parameterized queries (.eq(), .filter()), never string interpolation
- Command Injection: Use execFile() instead of exec(), validate/whitelist input
- Path Traversal: Validate paths, use path.resolve() with base directory check
- XSS: Remove dangerouslySetInnerHTML, use proper escaping, add CSP
- Stored XSS: Sanitize on input AND output
- Reflected XSS: Escape URL parameters before rendering
- Missing Auth: Add getServerSession() or equivalent auth check
- Weak Session: Add httpOnly, secure, sameSite flags
- IDOR: Add user_id filter to queries
- Missing RLS: Add proper RLS policy in migration SQL
- Missing Headers: Add to next.config.js or middleware.ts
- CORS: Restrict Access-Control-Allow-Origin to specific origins
- Exposed Secret: Move to .env, add to .gitignore

STEP 3: Validate the fix
Run in the project directory:
- pnpm typecheck (if available)
- pnpm lint (if available)

If validation fails, fix the errors. If unfixable, revert and report as "escalated".

STEP 4: Output the result

Use Write tool to create .claude/security-pentest/fixes/fix-{FINDING_ID}.json:

{
  "finding_id": "{FINDING_ID}",
  "status": "fixed|failed|escalated",
  "completed_at": "<ISO timestamp>",
  "file_changed": "src/...",
  "change_description": "What was changed and why",
  "validation": {
    "typecheck": "pass|fail|skipped",
    "lint": "pass|fail|skipped"
  }
}
```

## Step 7: Phase 5 - Verification (Wave 5 - Parallel Re-Test)

Update `index.json`: set `"status": "verifying"`, `"phase": 5`

For each fixed vulnerability, re-run the exploitation attempt using `webapp-testing` agents (parallel).

Each verification agent attempts the same exploit from Phase 3:

- If exploit STILL WORKS: mark fix as `"verification": "failed"` - the fix didn't hold
- If exploit BLOCKED: mark as `"verification": "passed"` - fix confirmed

Update the fix JSON files with verification results.

## Step 8: Phase 6 - Report Generation

Update `index.json`: set `"status": "complete"`, `"phase": 6`

Read all exploitation evidence files and fix results. Generate `.claude/security-pentest/report.md`:

````markdown
# Security Assessment Report

**Date**: YYYY-MM-DD
**Target**: <app name> @ localhost:3000
**Framework**: <detected framework>
**Methodology**: Shannon-inspired white-box penetration test
**Principle**: "No Exploit, No Report" - only confirmed vulnerabilities listed

## Executive Summary

- **Vulnerabilities Confirmed**: X
- **Critical**: X | **High**: X | **Medium**: X | **Low**: X | **Info**: X
- **Fixed**: X | **Verified**: X | **Remaining**: X

## Attack Surface

- API Routes Analyzed: X (Y unprotected)
- Pages Analyzed: X
- Input Vectors Found: X
- Data Flows Traced: X

## Confirmed Findings

### [SEVERITY] VULN-001: <Title>

**Category**: Injection / XSS / Auth / Authz / Headers
**File**: `src/app/api/example/route.ts:45`
**Status**: Fixed & Verified / Fixed / Open
**CVSS Estimate**: X.X

**Description**: <what the vulnerability is>

**Impact**: <what an attacker could achieve>

**Proof of Concept**:

```bash
curl -X POST http://localhost:3000/api/... \
  -H "Content-Type: application/json" \
  -d '{"payload": "..."}'
# Response: <evidence of exploitation>
```
````

**Fix Applied**: <description of fix, or "None - report-only mode">

**Verification**: <re-exploitation blocked / still exploitable>

---

[Repeat for each confirmed finding]

## Discarded Findings

Findings that could not be confirmed with a working exploit (per "No Exploit, No Report"):

| ID  | Category | Reason Discarded                    |
| --- | -------- | ----------------------------------- |
| ... | ...      | Could not construct working exploit |

## Security Posture Summary

### Strengths

- <what the app does well>

### Weaknesses

- <areas needing improvement>

### Recommendations

1. <prioritized recommendation>
2. ...

---

Generated by Security Pentest v1.0.0

```

## Progress Display

Throughout execution, output progress banners:

```

╔══════════════════════════════════════════════════════════════════╗
║ SECURITY PENTEST - Phase 1: Reconnaissance ║
╠══════════════════════════════════════════════════════════════════╣
║ Source Analyzer [RUNNING...] ║
║ Surface Mapper [RUNNING...] ║
╚══════════════════════════════════════════════════════════════════╝

```

Update banners between phases showing completed/running/pending status.

## Error Handling

- **Agent crashes**: Mark that phase's output as "failed", continue with available data
- **Dev server stops**: Pause and notify user to restart
- **Fix validation fails**: Mark fix as "failed", continue to next finding
- **No findings in any category**: Report clean bill of health
- **Exploitation agent can't confirm any findings**: Skip to report with "No confirmed vulnerabilities"

## Start Execution Now

1. Parse `$ARGUMENTS` for --fix-mode, --focus, --phase, --severity flags
2. Create `.claude/security-pentest/` directory structure
3. Write initial `index.json`
4. Check dev server is running on localhost:3000
5. Phase 1: Launch 2 recon agents in parallel
6. Phase 2: Launch analysis agents in parallel (filtered by --focus)
7. Phase 3: Launch exploitation agents in parallel (only for categories with findings)
8. Phase 4: Apply fixes sequentially (skip if --fix-mode report-only)
9. Phase 5: Verify fixes in parallel
10. Phase 6: Generate report.md
11. Print final summary to user
```
