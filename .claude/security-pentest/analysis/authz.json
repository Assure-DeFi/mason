{
  "category": "authz",
  "findings": [
    {
      "id": "AUTHZ-001",
      "type": "missing_rls",
      "severity": "critical",
      "confidence": "confirmed",
      "file": "src/app/api/setup/migrations/route.ts",
      "line": 535,
      "vulnerable_code": "CREATE POLICY \"Allow all on users\" ON mason_users FOR ALL USING (true) WITH CHECK (true);",
      "exploit_payload": "Any authenticated Supabase client (using the anon key) can SELECT, INSERT, UPDATE, DELETE all rows in every mason_* table. RLS is enabled but all 15 policies use USING(true) WITH CHECK(true), which is effectively no restriction at all.",
      "exploit_url": "curl -s 'https://<user-supabase>.supabase.co/rest/v1/mason_users?select=*' -H 'apikey: <anon_key>' -H 'Authorization: Bearer <anon_key>'",
      "impact": "In the BYOD (Bring Your Own Database) model, each user owns their own Supabase instance, so this is partially mitigated by isolation. However, if any user shares their Supabase URL/anon key (which are passed in HTTP headers and stored in localStorage), any party with those credentials can read/write ALL mason tables in that database, including other users' data if the instance is shared. The anon key is a public key by Supabase design - it's meant to be used with RLS providing actual restrictions. With USING(true), the anon key gives unrestricted access to all rows.",
      "remediation": "For the central DB: Replace open RLS policies with user-specific policies like USING (auth.uid()::text = user_id::text). For user BYOD databases: This is by design since each user owns their DB, but document that sharing the anon key grants full table access. Consider adding user_id-based RLS even in BYOD to protect against credential leakage."
    },
    {
      "id": "AUTHZ-002",
      "type": "idor",
      "severity": "medium",
      "confidence": "suspected",
      "file": "src/app/api/backlog/[id]/prd/route.ts",
      "line": 50,
      "vulnerable_code": "const { data, error: fetchError } = await supabase\n  .from(TABLES.PM_BACKLOG_ITEMS)\n  .select('prd_content')\n  .eq('id', id)\n  .single();",
      "exploit_payload": "All /api/backlog/[id]/* endpoints (prd, risk-analysis, events, analyze-risk) connect to the USER's own Supabase using credentials from x-supabase-url and x-supabase-anon-key headers. They filter only by item 'id' (the UUID path parameter) but NOT by user_id. If two users share the same Supabase instance, User A can access User B's items by guessing/enumerating UUIDs.",
      "exploit_url": "curl -s 'https://mason.assuredefi.com/api/backlog/<other-users-item-uuid>/prd' -H 'Cookie: <valid-session>' -H 'x-supabase-url: https://shared-instance.supabase.co' -H 'x-supabase-anon-key: <shared-anon-key>'",
      "impact": "In the current BYOD single-user model, the risk is low because each user has their own database. However, if multiple users share a Supabase instance (which the architecture permits), any authenticated user can read/modify any other user's backlog items, PRDs, risk analyses, and event history by guessing item UUIDs. The RLS policies (USING true) provide no protection.",
      "remediation": "Add .eq('user_id', session.user.id) or equivalent filtering to all /api/backlog/[id]/* queries. Even in BYOD model, this is defense-in-depth against shared instances or credential leakage."
    },
    {
      "id": "AUTHZ-003",
      "type": "idor",
      "severity": "medium",
      "confidence": "suspected",
      "file": "src/app/api/backlog/[id]/prd/route.ts",
      "line": 102,
      "vulnerable_code": "const { data, error: updateError } = await supabase\n  .from(TABLES.PM_BACKLOG_ITEMS)\n  .update({\n    prd_content,\n    updated_at: new Date().toISOString(),\n  })\n  .eq('id', id)\n  .select()\n  .single();",
      "exploit_payload": "PATCH /api/backlog/[id]/prd allows updating PRD content for ANY item accessible in the connected Supabase instance, filtered only by item UUID, not by user_id. Same issue as AUTHZ-002 but for write operations.",
      "exploit_url": "curl -X PATCH 'https://mason.assuredefi.com/api/backlog/<other-users-item-uuid>/prd' -H 'Cookie: <valid-session>' -H 'x-supabase-url: <url>' -H 'x-supabase-anon-key: <key>' -H 'Content-Type: application/json' -d '{\"prd_content\": \"overwritten\"}'",
      "impact": "An attacker with access to the same Supabase instance can overwrite any item's PRD content by targeting its UUID.",
      "remediation": "Add .eq('user_id', dbUserId) to the update query where dbUserId is derived from the authenticated session, not from client input."
    },
    {
      "id": "AUTHZ-004",
      "type": "mass_assignment",
      "severity": "medium",
      "confidence": "confirmed",
      "file": "src/app/api/backlog/[id]/events/route.ts",
      "line": 131,
      "vulnerable_code": "const { event_type, old_value, new_value, notes, dbUserId } = body;\n...\nuser_id: dbUserId || null,",
      "exploit_payload": "The POST /api/backlog/[id]/events endpoint accepts 'dbUserId' from the request body and directly inserts it as the 'user_id' field in the mason_item_events table. An attacker can set this to any UUID to impersonate another user as the author of an event.",
      "exploit_url": "curl -X POST 'https://mason.assuredefi.com/api/backlog/<item-id>/events' -H 'Cookie: <valid-session>' -H 'x-supabase-url: <url>' -H 'x-supabase-anon-key: <key>' -H 'Content-Type: application/json' -d '{\"event_type\": \"note_added\", \"notes\": \"malicious note\", \"dbUserId\": \"<victim-user-uuid>\"}'",
      "impact": "Allows forging audit trail events that appear to come from a different user. This undermines the integrity of the item event history/audit trail. An attacker can create misleading status_changed, prd_generated, or note_added events attributed to any user UUID.",
      "remediation": "Remove dbUserId from destructured body parameters. Instead, look up the user_id from the authenticated session: use session.user.id to find the corresponding mason_users record and use that UUID."
    },
    {
      "id": "AUTHZ-005",
      "type": "missing_rls",
      "severity": "high",
      "confidence": "confirmed",
      "file": "src/app/api/backlog/restore/route.ts",
      "line": 71,
      "vulnerable_code": "const backlogItem = {\n  title: filteredItem.title,\n  problem: filteredItem.problem,\n  solution: filteredItem.solution,\n  ...\n  status: 'new',\n  analysis_run_id: filteredItem.analysis_run_id,\n};",
      "exploit_payload": "The restore endpoint creates a new backlog item from a filtered item but does NOT set user_id or repository_id on the new backlog item. The created item will have NULL user_id and NULL repository_id, which means: (1) it won't appear in user-filtered dashboard views, (2) it bypasses any user_id-based access control on the v1 API endpoints.",
      "exploit_url": "curl -X POST 'https://mason.assuredefi.com/api/backlog/restore' -H 'Cookie: <valid-session>' -H 'x-supabase-url: <url>' -H 'x-supabase-anon-key: <key>' -H 'Content-Type: application/json' -d '{\"filteredItemId\": \"<any-filtered-item-uuid>\"}'",
      "impact": "Restored items are orphaned (no user_id, no repository_id). They become invisible in dashboard views but exist in the database. More critically, the source filtered_item lookup has no user_id filter, so an attacker on a shared instance can restore ANY user's filtered items.",
      "remediation": "Add user_id and repository_id (from the filtered item or session) to the backlogItem object before insertion. Also add .eq('user_id', sessionUserId) to the filtered item fetch query."
    },
    {
      "id": "AUTHZ-006",
      "type": "privilege_escalation",
      "severity": "high",
      "confidence": "confirmed",
      "file": "src/app/api/supabase/projects/[ref]/query/route.ts",
      "line": 49,
      "vulnerable_code": "export async function POST(request: NextRequest, { params }: RouteParams) {\n  const { ref: projectRef } = await params;\n  const authHeader = request.headers.get('Authorization');\n  ...\n  // NO getServerSession() check\n  ...\n  body: JSON.stringify({\n    query: body.query,\n    read_only: body.read_only ?? false,\n  }),",
      "exploit_payload": "The Supabase query proxy at /api/supabase/projects/[ref]/query does NOT check for a NextAuth session. It only validates the Authorization header (which is a Supabase OAuth token). Any unauthenticated user who has a valid Supabase management API token can execute ARBITRARY SQL (including write operations with read_only: false) against ANY Supabase project through this proxy. The proxy forwards the raw SQL query to the Supabase Management API without any query sanitization.",
      "exploit_url": "curl -X POST 'https://mason.assuredefi.com/api/supabase/projects/<project-ref>/query' -H 'Authorization: Bearer <stolen-supabase-token>' -H 'Content-Type: application/json' -d '{\"query\": \"SELECT * FROM mason_users; DROP TABLE mason_api_keys;\", \"read_only\": false}'",
      "impact": "Arbitrary SQL execution against any Supabase project. The attacker only needs a valid Supabase Management API token (which could be stolen from browser localStorage or intercepted). This is a Server-Side Request Forgery (SSRF) amplification - the Mason server acts as a proxy to execute SQL on behalf of the attacker, potentially bypassing IP-based restrictions on the Supabase Management API.",
      "remediation": "Add getServerSession(authOptions) check to validate the Mason session before proxying. Also consider: (1) enforcing read_only: true for non-migration queries, (2) implementing SQL query allowlisting, (3) validating that the projectRef belongs to the authenticated user."
    },
    {
      "id": "AUTHZ-007",
      "type": "privilege_escalation",
      "severity": "medium",
      "confidence": "confirmed",
      "file": "src/app/api/supabase/projects/[ref]/api-keys/route.ts",
      "line": 44,
      "vulnerable_code": "export async function GET(request: NextRequest, { params }: RouteParams) {\n  const { ref: projectRef } = await params;\n  const authHeader = request.headers.get('Authorization');\n  // NO getServerSession() check",
      "exploit_payload": "The /api/supabase/projects/[ref]/api-keys endpoint proxies Supabase Management API without checking Mason session. Same pattern as AUTHZ-006. Returns API keys (including service_role key) for any Supabase project accessible via the provided token.",
      "exploit_url": "curl -s 'https://mason.assuredefi.com/api/supabase/projects/<project-ref>/api-keys' -H 'Authorization: Bearer <supabase-oauth-token>'",
      "impact": "Exposes Supabase project API keys (including the service_role key which bypasses all RLS) to anyone with a valid Supabase OAuth token, without requiring Mason authentication. The service_role key gives unrestricted database access.",
      "remediation": "Add getServerSession(authOptions) check. Validate that the project belongs to the authenticated Mason user."
    },
    {
      "id": "AUTHZ-008",
      "type": "privilege_escalation",
      "severity": "medium",
      "confidence": "confirmed",
      "file": "src/app/api/supabase/projects/route.ts",
      "line": 38,
      "vulnerable_code": "export async function GET(request: NextRequest) {\n  const authHeader = request.headers.get('Authorization');\n  // NO getServerSession() check",
      "exploit_payload": "The /api/supabase/projects endpoint lists all Supabase projects without Mason session validation. Only requires a Supabase OAuth token in the Authorization header.",
      "exploit_url": "curl -s 'https://mason.assuredefi.com/api/supabase/projects' -H 'Authorization: Bearer <supabase-oauth-token>'",
      "impact": "Allows enumeration of all Supabase projects accessible to a token bearer, without requiring Mason authentication. Leaks project names, references, and metadata.",
      "remediation": "Add getServerSession(authOptions) check before proxying to Supabase Management API."
    },
    {
      "id": "AUTHZ-009",
      "type": "privilege_escalation",
      "severity": "low",
      "confidence": "confirmed",
      "file": "src/app/api/health/route.ts",
      "line": 40,
      "vulnerable_code": "export async function GET() {\n  // No auth check\n  ...\n  const { data, error } = await supabase.rpc('get_dlq_metrics');",
      "exploit_payload": "The /api/health endpoint is publicly accessible (no auth) and exposes DLQ (Dead Letter Queue) metrics including: total error count, error frequency (last hour/24h), max consecutive failures, oldest/newest error timestamps, and error type breakdown.",
      "exploit_url": "curl -s 'https://mason.assuredefi.com/api/health'",
      "impact": "Information disclosure. An attacker can monitor system health, error rates, and operational status without authentication. This reveals: (1) whether the system is experiencing failures, (2) types of errors occurring, (3) error frequency patterns. While health endpoints are commonly public, exposing detailed DLQ error metrics goes beyond a simple status check.",
      "remediation": "Split into two endpoints: (1) a simple public /api/health returning just {status: 'ok'}, (2) a protected /api/admin/health requiring admin session that returns detailed DLQ metrics."
    },
    {
      "id": "AUTHZ-010",
      "type": "idor",
      "severity": "medium",
      "confidence": "suspected",
      "file": "src/app/api/backlog/[id]/analyze-risk/route.ts",
      "line": 79,
      "vulnerable_code": "const { data: item, error: fetchError } = await supabase\n  .from(TABLES.PM_BACKLOG_ITEMS)\n  .select('*')\n  .eq('id', id)\n  .single();",
      "exploit_payload": "The analyze-risk endpoint fetches a backlog item by UUID without user_id filtering. It then fetches the linked repository and uses the client-provided GitHub token to access that repo's files. If on a shared Supabase instance, an attacker can trigger risk analysis on another user's backlog items.",
      "exploit_url": "curl -X POST 'https://mason.assuredefi.com/api/backlog/<other-users-item-uuid>/analyze-risk' -H 'Cookie: <valid-session>' -H 'x-supabase-url: <url>' -H 'x-supabase-anon-key: <key>' -H 'Content-Type: application/json' -d '{\"githubToken\": \"<attacker-token>\"}'",
      "impact": "Allows triggering dependency analysis on another user's backlog items. The analysis results (risk scores, breaking changes, affected files) are written back to the victim's item and dependency_analysis records. Could be used to overwrite legitimate analysis data.",
      "remediation": "Add .eq('user_id', sessionUserId) filter to the backlog item and repository queries."
    },
    {
      "id": "AUTHZ-011",
      "type": "idor",
      "severity": "low",
      "confidence": "suspected",
      "file": "src/app/api/backlog/[id]/events/route.ts",
      "line": 62,
      "vulnerable_code": "const { data: events, error } = await supabase\n  .from(TABLES.ITEM_EVENTS)\n  .select('*')\n  .eq('item_id', id)\n  .order('created_at', { ascending: true });",
      "exploit_payload": "GET /api/backlog/[id]/events returns all events for any item UUID without user_id filtering. On a shared instance, exposes another user's item event history.",
      "exploit_url": "curl -s 'https://mason.assuredefi.com/api/backlog/<other-users-item-uuid>/events' -H 'Cookie: <valid-session>' -H 'x-supabase-url: <url>' -H 'x-supabase-anon-key: <key>'",
      "impact": "Information disclosure of item status change history, PRD generation timestamps, branch creation, and PR creation events belonging to other users.",
      "remediation": "Join with mason_pm_backlog_items to verify the item belongs to the authenticated user, or add user_id column to events and filter directly."
    },
    {
      "id": "AUTHZ-012",
      "type": "privilege_escalation",
      "severity": "high",
      "confidence": "confirmed",
      "file": "src/lib/feature-flags.ts",
      "line": 20,
      "vulnerable_code": "ADMIN_USERS: ['chapo@assuredefi.com'],\n...\nexport function isAdmin(userEmail: string | null | undefined): boolean {\n  ...\n  return (FEATURE_FLAGS.ADMIN_USERS as readonly string[]).includes(userEmail);\n}",
      "exploit_payload": "Admin access is determined solely by matching the user's GitHub email against a hardcoded list in source code. The github_email field comes from the OAuth profile and can potentially be spoofed if GitHub allows email changes. There is no secondary verification (role in DB, MFA, etc.).",
      "exploit_url": "N/A - requires GitHub account with matching email or OAuth profile manipulation",
      "impact": "If an attacker can register a GitHub account with the email 'chapo@assuredefi.com' (e.g., if the original owner changes their email), they gain admin access to the /api/admin/stats endpoint and any admin-gated features. The admin check is email-based, not GitHub-ID-based.",
      "remediation": "Use github_id (immutable) instead of email for admin checks. Store admin role in the database rather than hardcoding in source. Consider adding MFA for admin operations."
    },
    {
      "id": "AUTHZ-013",
      "type": "missing_rls",
      "severity": "medium",
      "confidence": "confirmed",
      "file": "src/app/api/setup/migrations/route.ts",
      "line": 676,
      "vulnerable_code": "CREATE OR REPLACE FUNCTION get_dlq_metrics()\nRETURNS JSON\nLANGUAGE plpgsql\nSECURITY DEFINER\n...\nGRANT EXECUTE ON FUNCTION get_dlq_metrics() TO anon;",
      "exploit_payload": "The get_dlq_metrics() and bulk_retry_dlq() PostgreSQL functions are created with SECURITY DEFINER (runs as the function creator/superuser) and granted to the 'anon' role. Anyone with the Supabase anon key can call these functions and get DLQ metrics or bulk-retry error records.",
      "exploit_url": "curl -X POST 'https://<supabase-url>/rest/v1/rpc/bulk_retry_dlq' -H 'apikey: <anon_key>' -H 'Authorization: Bearer <anon_key>' -H 'Content-Type: application/json' -d '{\"max_age_hours\": 8760}'",
      "impact": "The anon role can: (1) read all DLQ error details via get_dlq_metrics(), (2) trigger bulk retries of failed items via bulk_retry_dlq(). SECURITY DEFINER means these functions bypass RLS entirely. The bulk_retry function can mark all errors as retried, potentially masking real failures.",
      "remediation": "Remove GRANT to anon role. Only grant to authenticated. Better yet, require the caller to be the specific user_id associated with the errors. Remove SECURITY DEFINER if not needed, or add explicit authorization checks inside the functions."
    },
    {
      "id": "AUTHZ-014",
      "type": "idor",
      "severity": "low",
      "confidence": "confirmed",
      "file": "src/app/api/backlog/[id]/risk-analysis/route.ts",
      "line": 47,
      "vulnerable_code": "const { data: analysis, error: fetchError } = await supabase\n  .from(TABLES.DEPENDENCY_ANALYSIS)\n  .select('*')\n  .eq('item_id', id)\n  .single();",
      "exploit_payload": "GET /api/backlog/[id]/risk-analysis returns dependency analysis for any item UUID without user_id filtering. On a shared Supabase instance, exposes another user's risk analysis data including target files, affected files, upstream dependencies, breaking changes, and test coverage gaps.",
      "exploit_url": "curl -s 'https://mason.assuredefi.com/api/backlog/<other-users-item-uuid>/risk-analysis' -H 'Cookie: <valid-session>' -H 'x-supabase-url: <url>' -H 'x-supabase-anon-key: <key>'",
      "impact": "Information disclosure of code analysis results: file paths, dependency graphs, test coverage gaps, and breaking change details for another user's codebase.",
      "remediation": "Join with mason_pm_backlog_items to verify the item belongs to the authenticated user before returning analysis data."
    },
    {
      "id": "AUTHZ-015",
      "type": "privilege_escalation",
      "severity": "medium",
      "confidence": "confirmed",
      "file": "src/app/api/supabase/projects/[ref]/route.ts",
      "line": 25,
      "vulnerable_code": "export async function GET(request: NextRequest, { params }: RouteParams) {\n  const { ref: projectRef } = await params;\n  const authHeader = request.headers.get('Authorization');\n  // NO getServerSession() check",
      "exploit_payload": "The /api/supabase/projects/[ref] endpoint returns full project details (including database host, region, organization) for any project ref without Mason session validation.",
      "exploit_url": "curl -s 'https://mason.assuredefi.com/api/supabase/projects/<project-ref>' -H 'Authorization: Bearer <supabase-oauth-token>'",
      "impact": "Exposes Supabase project configuration details (database host, region, status, organization_id) without Mason authentication. Combined with AUTHZ-007, an attacker with a stolen Supabase token can enumerate projects and retrieve their API keys.",
      "remediation": "Add getServerSession(authOptions) check. Validate project ownership against the authenticated Mason user."
    }
  ],
  "summary": {
    "total_findings": 15,
    "critical": 1,
    "high": 3,
    "medium": 7,
    "low": 4,
    "key_themes": [
      "All 15 RLS policies use USING(true) WITH CHECK(true) - effectively no row-level security at the database layer. Security relies entirely on application-level user_id filtering.",
      "The /api/backlog/[id]/* endpoints (prd, events, risk-analysis, analyze-risk) do NOT filter by user_id. They rely on the user connecting to their own Supabase instance for isolation, but this breaks if instances are shared.",
      "The Supabase Management API proxy endpoints (/api/supabase/projects/*, /api/supabase/projects/[ref]/query, /api/supabase/projects/[ref]/api-keys) lack Mason session validation. They only check for a Supabase OAuth token, making them usable by anyone with a stolen token.",
      "The v1 API endpoints (backlog/next, backlog/[id]/start, backlog/[id]/complete, backlog/[id]/fail) properly filter by user_id derived from API key validation - these are well-protected.",
      "The events endpoint accepts user_id from the request body (dbUserId), allowing audit trail forgery.",
      "The restore endpoint creates backlog items without user_id or repository_id, creating orphaned records.",
      "SECURITY DEFINER functions with anon grants allow unauthenticated database function execution."
    ]
  }
}
