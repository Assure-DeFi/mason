{
  "category": "auth",
  "findings": [
    {
      "id": "AUTH-001",
      "type": "oauth_flaw",
      "severity": "high",
      "confidence": "confirmed",
      "file": "src/app/api/auth/supabase/callback/route.ts",
      "line": 163,
      "vulnerable_code": "cookieStore.set('supabase_oauth_tokens', tokenData, {\n  httpOnly: false, // Client needs to read this\n  secure: process.env.NODE_ENV === 'production',\n  sameSite: 'lax',\n  maxAge: 60, // 1 minute\n  path: '/',\n});",
      "exploit_payload": "Any JavaScript running on the page (including XSS or malicious browser extensions) can read the supabase_oauth_tokens cookie containing the Supabase Management API access_token and refresh_token. The access token grants database:write, api-keys:read, and projects:read scopes on the user's Supabase account. A refresh token allows indefinite persistence beyond the 60-second cookie lifetime if captured.",
      "exploit_url": "// From browser console or injected script:\ndocument.cookie.split(';').find(c => c.trim().startsWith('supabase_oauth_tokens'));\n// Returns: {\"accessToken\":\"sbp_...\",\"refreshToken\":\"sbr_...\",\"expiresAt\":...}",
      "impact": "Full compromise of user's Supabase account - attacker can read all projects, read API keys, and execute arbitrary SQL writes against any of the user's databases. The refresh token allows long-term persistence. This is a Supabase Management API token, not a project-level token, so it affects ALL the user's Supabase projects.",
      "remediation": "Pass tokens via a short-lived httpOnly encrypted cookie that the server decrypts and returns via a secure API endpoint, or use a server-side session store. If client-side reading is absolutely required, use a technique like embedding the token in the HTML response body within a script tag (one-time render) rather than a persistent non-httpOnly cookie."
    },
    {
      "id": "AUTH-002",
      "type": "missing_auth",
      "severity": "medium",
      "confidence": "confirmed",
      "file": "src/app/api/supabase/projects/route.ts",
      "line": 38,
      "vulnerable_code": "export async function GET(request: NextRequest) {\n  const authHeader = request.headers.get('Authorization');\n\n  if (!authHeader || !authHeader.startsWith('Bearer ')) {\n    return unauthorized('Missing or invalid Authorization header');\n  }\n  // ... proxies to Supabase Management API",
      "exploit_payload": "These Supabase proxy endpoints (/api/supabase/projects, /api/supabase/projects/[ref], /api/supabase/projects/[ref]/api-keys, /api/supabase/projects/[ref]/query) only check for a Bearer token in the Authorization header. They do NOT validate a NextAuth session. Any party with a valid Supabase OAuth token can use these endpoints as an SSRF relay to the Supabase Management API, even without being a Mason user.",
      "exploit_url": "curl -s 'https://mason.yourdomain.com/api/supabase/projects' -H 'Authorization: Bearer sbp_stolen_token'",
      "impact": "These endpoints act as unauthenticated SSRF proxies to the Supabase Management API. While the Supabase API itself requires a valid token, the Mason server is used as a relay -- this bypasses any IP allowlisting on Supabase and obscures the attacker's origin. The /query endpoint is particularly dangerous as it proxies arbitrary SQL execution.",
      "remediation": "Add getServerSession(authOptions) check to all four Supabase proxy endpoints. Only authenticated Mason users should be able to use these proxies. This ensures the proxy cannot be used by arbitrary external parties."
    },
    {
      "id": "AUTH-003",
      "type": "missing_auth",
      "severity": "medium",
      "confidence": "confirmed",
      "file": "src/app/api/auth/supabase/refresh/route.ts",
      "line": 17,
      "vulnerable_code": "export async function POST(request: NextRequest) {\n  try {\n    const { refreshToken } = await request.json();\n    // ... no session check\n    const tokens = await refreshAccessToken({ refreshToken, clientId, clientSecret });",
      "exploit_payload": "The /api/auth/supabase/refresh endpoint requires no authentication. Anyone with a Supabase refresh token (leaked, stolen, or expired-but-valid) can exchange it for a fresh access token using Mason's OAuth client credentials without being authenticated to Mason.",
      "exploit_url": "curl -s -X POST 'https://mason.yourdomain.com/api/auth/supabase/refresh' -H 'Content-Type: application/json' -d '{\"refreshToken\": \"sbr_leaked_token\"}'",
      "impact": "Attacker can use Mason's server-side OAuth client_id and client_secret to mint fresh Supabase Management API tokens from any stolen refresh token. This turns Mason into a token-minting service. The new tokens are returned directly in the response body.",
      "remediation": "Add getServerSession(authOptions) check. Only authenticated Mason users should be able to refresh their own tokens. Additionally, consider binding refresh tokens to specific user sessions."
    },
    {
      "id": "AUTH-004",
      "type": "api_key_weakness",
      "severity": "medium",
      "confidence": "confirmed",
      "file": "src/lib/rate-limit/config.ts",
      "line": 14,
      "vulnerable_code": "const isUpstashConfigured = Boolean(\n  process.env.UPSTASH_REDIS_REST_URL && process.env.UPSTASH_REDIS_REST_TOKEN,\n);\n// ...\npublicEndpoint: isUpstashConfigured ? new Ratelimit({...}) : null,",
      "exploit_payload": "Rate limiting is entirely disabled when Upstash Redis is not configured. The checkRateLimit function returns { success: true } when no limiter exists. If the deployment lacks UPSTASH_REDIS_REST_URL or UPSTASH_REDIS_REST_TOKEN environment variables, all API endpoints have zero rate limiting, enabling unrestricted brute-force attacks on API key validation.",
      "exploit_url": "# Brute-force API key validation with no rate limits:\nfor i in $(seq 1 1000000); do\n  curl -s 'https://mason.yourdomain.com/api/v1/analysis' -H 'Authorization: Bearer mason_attempt_'$i\ndone",
      "impact": "API keys use 24 bytes of randomness (base64url = ~192 bits of entropy), so brute-force of the key space is infeasible even without rate limiting. However, without rate limiting an attacker can test leaked partial keys or perform dictionary attacks at unlimited speed. More critically, the AI-heavy endpoints (10 req/hr limit) and strict endpoints (5 req/hr limit) become unbounded, enabling abuse of compute-expensive operations.",
      "remediation": "Add a fallback rate limiter (in-memory Map with sliding window) when Redis is not configured. Never allow zero rate limiting in production. At minimum, log a warning at startup if Upstash is not configured."
    },
    {
      "id": "AUTH-005",
      "type": "weak_session",
      "severity": "low",
      "confidence": "confirmed",
      "file": "src/lib/auth/auth-options.ts",
      "line": 126,
      "vulnerable_code": "token.tempAccessToken = account.access_token ?? '';",
      "exploit_payload": "The GitHub OAuth access token is stored in the JWT token as tempAccessToken during initial sign-in. Since the session strategy is JWT (not database sessions), this token is encoded in the JWT cookie. While the intent is for the client to extract it and store in localStorage, the JWT itself persists in the browser cookie. If the JWT secret is weak or leaked, the GitHub access token (with full repo scope) can be extracted by decoding the JWT.",
      "exploit_url": "# If NEXTAUTH_SECRET is known/weak:\nnode -e \"const jwt = require('jsonwebtoken'); console.log(jwt.decode(process.argv[1]))\" '<session-cookie-value>'",
      "impact": "The GitHub access token has 'repo' scope (full repository access). If the JWT can be decoded (weak NEXTAUTH_SECRET, or the token is intercepted), the attacker gets full read/write access to all of the user's GitHub repositories. The token is supposed to be cleared after the first session callback, but it persists in the JWT until the next token rotation.",
      "remediation": "Clear tempAccessToken from the JWT after the first session callback by setting token.tempAccessToken = undefined in a subsequent jwt callback invocation. Consider using a server-side session store instead of JWT to avoid embedding secrets in client-visible tokens. Ensure NEXTAUTH_SECRET is cryptographically strong (32+ random bytes)."
    },
    {
      "id": "AUTH-006",
      "type": "missing_auth",
      "severity": "low",
      "confidence": "confirmed",
      "file": "src/app/api/health/route.ts",
      "line": 40,
      "vulnerable_code": "export async function GET() {\n  // ... no auth check\n  const supabase = createServerClient();\n  const { data, error } = await supabase.rpc('get_dlq_metrics');",
      "exploit_payload": "The health endpoint is publicly accessible and exposes internal DLQ (Dead Letter Queue) metrics including: total error count, last 24h/1h error counts, oldest/newest error timestamps, max consecutive failure count, and error type breakdown with counts.",
      "exploit_url": "curl -s 'https://mason.yourdomain.com/api/health' | jq '.dlq'",
      "impact": "Information disclosure of internal system health. An attacker can monitor error rates, identify when the system is degraded, learn about internal error categorization, and time attacks during periods of high failure rates. The error_types array may reveal internal infrastructure details (database connection failures, API timeouts, etc.).",
      "remediation": "Either remove DLQ metrics from the public health endpoint (return only {status: 'ok'} publicly) or add authentication. The detailed DLQ metrics should be behind admin auth. A common pattern is public /health returning only status, and authenticated /health/detailed returning full metrics."
    },
    {
      "id": "AUTH-007",
      "type": "privilege_escalation",
      "severity": "low",
      "confidence": "confirmed",
      "file": "src/lib/feature-flags.ts",
      "line": 20,
      "vulnerable_code": "ADMIN_USERS: ['chapo@assuredefi.com'],\n\nexport function isAdmin(userEmail: string | null | undefined): boolean {\n  if (!userEmail) { return false; }\n  return (FEATURE_FLAGS.ADMIN_USERS as readonly string[]).includes(userEmail);\n}",
      "exploit_payload": "Admin authorization is hardcoded in source code using email-based matching. The email comes from the GitHub OAuth profile (github_email field). If an attacker can control their GitHub account's primary email to match a hardcoded admin email, they would gain admin access. Additionally, the admin check uses simple string matching with no domain verification.",
      "exploit_url": "# The admin check is properly enforced in /api/admin/stats route (line 18):\n# if (!session?.user?.id || !isAdmin(session.user.github_email))\n# Actual exploit requires GitHub email spoofing which is difficult but not impossible.",
      "impact": "Limited impact in current codebase -- admin access only grants read access to platform stats (active users, active repos, deleted counts). However, as admin features expand, hardcoded email-based admin checks become increasingly risky.",
      "remediation": "Move admin role to database (is_admin column on mason_users table). Validate email domain in addition to address. Consider requiring GitHub organization membership for admin access instead of email matching."
    },
    {
      "id": "AUTH-008",
      "type": "missing_auth",
      "severity": "low",
      "confidence": "confirmed",
      "file": "src/app/api/docs/openapi.json/route.ts",
      "line": 14,
      "vulnerable_code": "export async function GET(): Promise<NextResponse> {\n  const document = generateOpenAPIDocument();\n  return NextResponse.json(document, {\n    headers: {\n      'Access-Control-Allow-Origin': '*',",
      "exploit_payload": "The OpenAPI spec endpoint is publicly accessible with wildcard CORS. It exposes the complete API surface including all endpoint paths, parameter schemas, authentication methods, and the NextAuth session cookie name (next-auth.session-token). The session cookie name leakage aids targeted session hijacking.",
      "exploit_url": "curl -s 'https://mason.yourdomain.com/api/docs/openapi.json' | jq '.components.securitySchemes'",
      "impact": "Full API reconnaissance -- attacker learns all endpoints, parameter formats, auth mechanisms, and the exact session cookie name. The wildcard CORS allows any website to fetch this spec. The OpenAPI spec also reveals server URLs (localhost:3000 and production domain hint).",
      "remediation": "Remove wildcard CORS (restrict to known documentation hosts). Consider adding session auth to limit access to authenticated users. Remove the sessionAuth security scheme details (cookie name) from the public spec. Remove localhost server entry from production builds."
    },
    {
      "id": "AUTH-009",
      "type": "missing_auth",
      "severity": "medium",
      "confidence": "confirmed",
      "file": "src/app/api/backlog/[id]/prd/route.ts",
      "line": 98,
      "vulnerable_code": "// PATCH handler:\nconst supabase = createClient(supabaseUrl, supabaseAnonKey);\nconst { data, error: updateError } = await supabase\n  .from(TABLES.PM_BACKLOG_ITEMS)\n  .update({ prd_content, updated_at: new Date().toISOString() })\n  .eq('id', id)\n  .select()\n  .single();",
      "exploit_payload": "Multiple /api/backlog/* endpoints accept user-supplied Supabase URL and anon key via x-supabase-url and x-supabase-anon-key headers, then create a Supabase client with those credentials. While session auth is checked, an authenticated user can supply ANY Supabase URL/key pair -- potentially pointing to another user's database. The query only filters by item ID, not by user_id. This is a Server-Side Request Forgery (SSRF) vector where the Mason server makes requests to arbitrary Supabase instances.",
      "exploit_url": "curl -s -X PATCH 'https://mason.yourdomain.com/api/backlog/TARGET_ITEM_UUID/prd' \\\n  -H 'Cookie: next-auth.session-token=VALID_SESSION' \\\n  -H 'x-supabase-url: https://VICTIM_PROJECT.supabase.co' \\\n  -H 'x-supabase-anon-key: VICTIM_ANON_KEY' \\\n  -H 'Content-Type: application/json' \\\n  -d '{\"prd_content\": \"modified\"}'",
      "impact": "An authenticated Mason user could potentially read or write data in another user's Supabase database if they know (or guess) the target's Supabase URL and anon key. The anon key is typically public (used in client-side code), so the barrier is low. Affected endpoints: /api/backlog/[id]/prd (GET/PATCH), /api/backlog/[id]/risk-analysis (GET), /api/backlog/[id]/events (GET/POST), /api/backlog/restore (POST), /api/backlog/[id]/analyze-risk (POST). The server acts as a proxy making requests FROM the server IP, which may bypass RLS policies that trust server-side requests.",
      "remediation": "Validate that the supplied Supabase URL matches the one stored for the authenticated user's account. Alternatively, store the user's Supabase credentials server-side (encrypted) and look them up by session user ID rather than accepting arbitrary credentials from headers. At minimum, always filter queries by user_id from the authenticated session, not just by item ID."
    },
    {
      "id": "AUTH-010",
      "type": "api_key_weakness",
      "severity": "low",
      "confidence": "confirmed",
      "file": "src/lib/auth/api-key.ts",
      "line": 103,
      "vulnerable_code": "const { data: joined, error: joinError } = await supabase\n  .from(TABLES.API_KEYS)\n  .select('id, key_hash, mason_users (...)')\n  .eq('key_hash', hash)\n  .single();",
      "exploit_payload": "The timing-safe comparison (timingSafeEqual) at line 147 is applied AFTER the database lookup by hash, which means the database query timing already leaks whether a matching hash exists. The timingSafeEqual comparison is redundant since both the computed hash and stored hash derive from SHA-256 -- if the database returns a row, the hashes will always match. The actual timing side-channel is in the database query latency (hash found vs not found).",
      "exploit_url": "# Timing attack on database query latency (theoretical):\n# Measure response time difference between valid-hash-found and no-match\n# In practice, this is mitigated by network jitter and the high entropy of SHA-256 hashes",
      "impact": "Theoretical only. The SHA-256 hash space is 256 bits, making it infeasible to enumerate hashes even with timing information. The timing-safe comparison provides defense-in-depth but the real security comes from the hash entropy. No practical exploit exists.",
      "remediation": "No action required -- the current implementation is adequate. The timing-safe comparison is good defense-in-depth practice. For completeness, you could add a constant-time database query pattern (always query, compare result) but the practical risk is negligible."
    }
  ],
  "summary": {
    "total_findings": 10,
    "critical": 0,
    "high": 1,
    "medium": 3,
    "low": 5,
    "informational": 1,
    "notes": "The most significant finding is AUTH-001 (non-httpOnly cookie containing Supabase Management API tokens). The Supabase proxy endpoints (AUTH-002) and token refresh endpoint (AUTH-003) lack session validation, creating relay/minting attack surfaces. The user-supplied Supabase credentials pattern (AUTH-009) enables cross-tenant SSRF. No critical auth bypasses were found -- all session-protected and API-key-protected endpoints properly validate their respective auth mechanisms. The admin endpoint correctly checks both session AND admin role. OAuth PKCE and CSRF state are properly implemented."
  }
}
