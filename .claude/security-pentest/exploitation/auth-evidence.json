{
  "category": "authentication",
  "tested_at": "2026-02-06T22:52:39-05:00",
  "base_url": "http://localhost:3000",
  "findings": [
    {
      "id": "AUTH-001",
      "title": "OAuth tokens stored in non-httpOnly cookie",
      "status": "confirmed",
      "severity": "high",
      "exploit_type": "code_review",
      "file_location": "src/app/api/auth/supabase/callback/route.ts",
      "line_number": 76,
      "code_evidence": "cookieStore.set('supabase_oauth_tokens', tokenData, {\n  httpOnly: false, // Client needs to read this\n  secure: process.env.NODE_ENV === 'production',\n  sameSite: 'lax',\n  maxAge: 60,\n  path: '/'\n})",
      "impact_demonstrated": "OAuth tokens (access_token, refresh_token) are stored in a JavaScript-accessible cookie for 60 seconds. XSS attacks can steal these tokens during the window.",
      "remediation": "Use httpOnly: true and pass tokens to client via server-side props or a secure server action instead of client-readable cookies.",
      "cwe": "CWE-1004: Sensitive Cookie Without 'HttpOnly' Flag"
    },
    {
      "id": "AUTH-002",
      "title": "Supabase proxy endpoints lack session authentication",
      "status": "not_exploitable",
      "severity": "medium",
      "exploit_request": {
        "method": "GET",
        "url": "http://localhost:3000/api/supabase/projects",
        "headers": {
          "Authorization": "Bearer fake_token_12345"
        }
      },
      "exploit_response": {
        "status_code": 401,
        "body": "{\"success\":false,\"error\":{\"code\":\"EXTERNAL_SERVICE_ERROR\",\"message\":\"JWT could not be decoded\"}}"
      },
      "proof_of_concept": "curl -s http://localhost:3000/api/supabase/projects -H 'Authorization: Bearer fake_token_12345'",
      "impact_demonstrated": "Endpoint returns 401 when invalid JWT provided. However, it DOES attempt to proxy to Supabase before validating NextAuth session. The endpoint lacks session.user check but Supabase JWT validation provides defense-in-depth.",
      "file_location": "src/app/api/supabase/projects/route.ts",
      "note": "While not directly exploitable due to Supabase's own JWT validation, missing session check violates defense-in-depth principle. Recommendation: Add session validation before proxying."
    },
    {
      "id": "AUTH-003",
      "title": "Unauthenticated token refresh endpoint",
      "status": "not_exploitable",
      "severity": "medium",
      "exploit_request": {
        "method": "POST",
        "url": "http://localhost:3000/api/auth/supabase/refresh",
        "headers": {
          "Content-Type": "application/json"
        },
        "body": "{\"refreshToken\": \"fake_refresh_token\"}"
      },
      "exploit_response": {
        "status_code": 401,
        "body": "{\"success\":false,\"error\":{\"code\":\"UNAUTHORIZED\",\"message\":\"Failed to refresh token\"}}"
      },
      "proof_of_concept": "curl -s -X POST http://localhost:3000/api/auth/supabase/refresh -H 'Content-Type: application/json' -d '{\"refreshToken\": \"fake_refresh_token\"}'",
      "impact_demonstrated": "Endpoint returns 401 on invalid refresh token. While it doesn't check NextAuth session, Supabase's own validation prevents exploitation.",
      "file_location": "src/app/api/auth/supabase/refresh/route.ts",
      "note": "Similar to AUTH-002, lacks session check but protected by Supabase validation. Recommendation: Add session validation for defense-in-depth."
    },
    {
      "id": "AUTH-006",
      "title": "Health endpoint accessible without authentication",
      "status": "confirmed",
      "severity": "low",
      "exploit_request": {
        "method": "GET",
        "url": "http://localhost:3000/api/health",
        "headers": {}
      },
      "exploit_response": {
        "status_code": 200,
        "body": "{\"status\":\"ok\",\"timestamp\":1770436334759,\"dlq\":null}"
      },
      "proof_of_concept": "curl -s http://localhost:3000/api/health",
      "impact_demonstrated": "Health endpoint returns internal system status without authentication. Currently exposes: system status, timestamp, DLQ metrics (null in this case). Information disclosure is minimal but violates principle of least privilege.",
      "file_location": "src/app/api/health/route.ts",
      "remediation": "Add basic authentication or API key requirement for health endpoint, or limit exposed information to just {\"status\":\"ok\"}.",
      "cwe": "CWE-200: Exposure of Sensitive Information to an Unauthorized Actor"
    },
    {
      "id": "AUTH-008",
      "title": "OpenAPI specification with wildcard CORS",
      "status": "confirmed",
      "severity": "low",
      "exploit_request": {
        "method": "GET",
        "url": "http://localhost:3000/api/docs/openapi.json",
        "headers": {
          "Origin": "https://evil.com"
        }
      },
      "exploit_response": {
        "status_code": 200,
        "headers": {
          "access-control-allow-origin": "*",
          "access-control-allow-methods": "GET, OPTIONS"
        }
      },
      "proof_of_concept": "curl -s -H 'Origin: https://evil.com' http://localhost:3000/api/docs/openapi.json",
      "impact_demonstrated": "OpenAPI spec is accessible from any origin via CORS wildcard. While spec itself may be intended as public documentation, wildcard CORS is generally discouraged.",
      "file_location": "src/app/api/docs/openapi.json/route.ts",
      "remediation": "Either restrict CORS to specific trusted origins or document that OpenAPI spec is intentionally public. If public, consider rate limiting.",
      "cwe": "CWE-942: Permissive Cross-domain Policy with Untrusted Domains"
    }
  ],
  "summary": {
    "total_tested": 5,
    "confirmed": 3,
    "not_exploitable": 2,
    "high_severity": 1,
    "medium_severity": 2,
    "low_severity": 2
  }
}
