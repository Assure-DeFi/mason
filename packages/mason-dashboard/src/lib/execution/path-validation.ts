/**
 * Path Validation Utilities for Execution Engine
 *
 * Validates file paths generated by AI before write operations.
 * Prevents path traversal attacks and ensures files stay within
 * the repository boundaries.
 */

/**
 * Result of path validation
 */
export interface PathValidationResult {
  valid: boolean;
  error?: string;
  normalizedPath?: string;
}

/**
 * Options for path validation
 */
export interface PathValidationOptions {
  /** Allowed directory prefixes (e.g., ['src/', 'packages/']) */
  allowedPrefixes?: string[];
  /** Blocked file patterns (e.g., ['.env', 'credentials']) */
  blockedPatterns?: string[];
}

/**
 * Default blocked patterns for sensitive files
 */
const DEFAULT_BLOCKED_PATTERNS = [
  '.env',
  '.env.local',
  '.env.production',
  '.env.development',
  'credentials',
  'secrets',
  '.git/',
  '.github/workflows/',
  'node_modules/',
];

/**
 * Validates a single file path for security issues.
 *
 * Checks:
 * - No path traversal (.. components)
 * - No absolute paths (starting with /)
 * - No sensitive file patterns
 * - Path is normalized and within allowed directories
 *
 * @param path - The file path to validate
 * @param options - Validation options
 * @returns Validation result with normalized path if valid
 */
export function validateFilePath(
  path: string,
  options: PathValidationOptions = {},
): PathValidationResult {
  // Reject empty paths
  if (!path || path.trim() === '') {
    return { valid: false, error: 'Empty file path' };
  }

  const trimmedPath = path.trim();

  // Reject absolute paths
  if (trimmedPath.startsWith('/')) {
    return {
      valid: false,
      error: `Absolute paths not allowed: ${trimmedPath}`,
    };
  }

  // Reject Windows-style absolute paths
  if (/^[a-zA-Z]:[\\/]/.test(trimmedPath)) {
    return {
      valid: false,
      error: `Absolute Windows paths not allowed: ${trimmedPath}`,
    };
  }

  // Normalize path separators
  const normalizedPath = trimmedPath.replace(/\\/g, '/');

  // Reject path traversal attempts
  const segments = normalizedPath.split('/');
  for (const segment of segments) {
    if (segment === '..') {
      return {
        valid: false,
        error: `Path traversal not allowed: ${trimmedPath}`,
      };
    }
    // Also catch encoded traversal attempts
    if (segment.includes('%2e%2e') || segment.includes('%2E%2E')) {
      return {
        valid: false,
        error: `Encoded path traversal not allowed: ${trimmedPath}`,
      };
    }
  }

  // Check for blocked patterns
  const blockedPatterns = [
    ...DEFAULT_BLOCKED_PATTERNS,
    ...(options.blockedPatterns ?? []),
  ];
  for (const pattern of blockedPatterns) {
    if (
      normalizedPath.includes(pattern) ||
      normalizedPath.startsWith(pattern)
    ) {
      return {
        valid: false,
        error: `Blocked file pattern: ${pattern} in ${trimmedPath}`,
      };
    }
  }

  // If allowed prefixes specified, check path starts with one
  if (options.allowedPrefixes && options.allowedPrefixes.length > 0) {
    const hasAllowedPrefix = options.allowedPrefixes.some(
      (prefix) =>
        normalizedPath.startsWith(prefix) ||
        normalizedPath === prefix.replace(/\/$/, ''),
    );
    if (!hasAllowedPrefix) {
      return {
        valid: false,
        error: `Path must start with one of: ${options.allowedPrefixes.join(', ')}. Got: ${trimmedPath}`,
      };
    }
  }

  // Remove redundant segments (e.g., ./ or double slashes)
  const cleanedSegments = segments.filter((s) => s !== '' && s !== '.');
  const cleanedPath = cleanedSegments.join('/');

  if (cleanedPath === '') {
    return { valid: false, error: 'Path resolved to empty' };
  }

  return {
    valid: true,
    normalizedPath: cleanedPath,
  };
}

/**
 * Validates multiple file paths and returns aggregated results.
 *
 * @param paths - Array of file paths to validate
 * @param options - Validation options
 * @returns Object with valid paths and any errors
 */
export function validateFilePaths(
  paths: string[],
  options: PathValidationOptions = {},
): {
  valid: boolean;
  validPaths: string[];
  errors: Array<{ path: string; error: string }>;
} {
  const validPaths: string[] = [];
  const errors: Array<{ path: string; error: string }> = [];

  for (const path of paths) {
    const result = validateFilePath(path, options);
    if (result.valid && result.normalizedPath) {
      validPaths.push(result.normalizedPath);
    } else {
      errors.push({ path, error: result.error ?? 'Unknown validation error' });
    }
  }

  return {
    valid: errors.length === 0,
    validPaths,
    errors,
  };
}

/**
 * Logs a file operation for audit purposes.
 * Outputs to console with structured format for log aggregation.
 *
 * @param operation - The operation type (e.g., 'write', 'create', 'update')
 * @param path - The file path being operated on
 * @param metadata - Additional context for the audit log
 */
export function auditLogFileOperation(
  operation: 'write' | 'create' | 'update' | 'delete' | 'validate',
  path: string,
  metadata?: {
    runId?: string;
    itemId?: string;
    success?: boolean;
    error?: string;
    contentLength?: number;
  },
): void {
  const timestamp = new Date().toISOString();
  const logEntry = {
    timestamp,
    type: 'FILE_OPERATION_AUDIT',
    operation,
    path,
    ...metadata,
  };

  // Use structured logging format
  console.log('[FileAudit]', JSON.stringify(logEntry));
}
